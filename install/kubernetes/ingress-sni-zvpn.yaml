# Example configuration using Envoy v2 bootstrap, custom envoy configuration with SNI and
# sample 'zero vpn' port forwarding. This needs to be manually updated for new domains and services,
# work in progress to automate it by having Pilot generate LDS v2 with SNI and capture the zvpn ports from
# annotations.
#
# Setting up SNI in LDSv2:
# https://www.envoyproxy.io/docs/envoy/latest/faq/sni.html#faq-how-to-setup-sni
apiVersion: v1
kind: ConfigMap
metadata:
  name: envoy-config
  namespace: istio-system
data:
  envoy.yaml: |
    # You can include a custom bootstrap envoy yaml, updating the path in the 'args'
    # Ingress configuration using Envoy v2 bootstrap.
    #
    # Has 'zero vpn' port forwarding for the control plane - allowing machines outside the VPN with proper certificates
    # to connect to Istio.
    #
    # Current config has a sample port open, exposing an internal service. This will be rolled into LDS and automatically
    # exposed using service annotations in a future version.
    #
    # To customize the envoy config, create a config map and update the ingress config to use the custom envoy bootstrap
    # from the config map.
    #
    # Setting up SNI in LDSv2:
    # https://www.envoyproxy.io/docs/envoy/latest/faq/sni.html#faq-how-to-setup-sni
    stats_config:
      # Without this option it create a lot of regex, may run out of space.
      use_all_default_tags: false

    admin:
      access_log_path: /dev/stdout
      address:
        # Only allow debugging from localhost
        socket_address: { address: 127.0.0.1, port_value: 15000 }

    dynamic_resources:
      lds_config:
        api_config_source:
          api_type: REST_LEGACY
          refresh_delay: 10s
          # Pilot cluster is named 'rds' for compatibility with existing LDS, which hardcodes this name for the RDS API.
          cluster_names: [rds]
      cds_config:
         api_config_source:
            api_type: REST_LEGACY
            refresh_delay: 10s
            cluster_names: [rds]
      #Required - without it cds_config doesn't work
      deprecated_v1:
        sds_config:
          api_config_source:
                api_type: REST_LEGACY
                refresh_delay: 10s
                cluster_names: [rds]

    static_resources:
      listeners:
      # HTTP using manual config. Pilot doesn't override this, can be customized by user.
      - name: http8080
        address:
          socket_address: { address: 0.0.0.0, port_value: 8082 }
        filter_chains:
        - filters:
          - name: envoy.http_connection_manager
            # TODO: add mixer
            config:
              stat_prefix: http80
              codec_type: AUTO
              rds:
                # Will be passed as part of the URL /v1/routes/80/istio-proxy/ingress~~...
                route_config_name: "80"
                config_source:
                  api_config_source:
                      api_type: REST_LEGACY
                      refresh_delay: 10s
                      cluster_names: [rds]
              http_filters:
                - name: envoy.router

      # HTTPS - currently manually configured, until pilot generates LDSv2 for ingress.
      # If using kube-lego, certificate can be retrieved for testing with:
      #   kubectl get secret -n istio-system httpbin-tls -o jsonpath='{.data.tls\.key}' |base64 -d > /etc/istio/httpbin-certs/tls.key
      #   kubectl get secret -n istio-system httpbin-tls -o jsonpath='{.data.crt\.key}' |base64 -d > /etc/istio/httpbin-certs/crt.key
      #      - name: http443
      #        address:
      #          socket_address: { address: 0.0.0.0, port_value: 8443 }
      #        filter_chains:
      #        - filter_chain_match:
      #            sni_domains: "httpbin.weekly.istio.webinf.info"
      #          tls_context:
      #            common_tls_context:
      #              tls_certificates:
      #                - certificate_chain: { filename: "/etc/istio/httpbin-certs/tls.crt" }
      #                  private_key: { filename: "/etc/istio/httpbin-certs/tls.key" }
      #          filters:
      #          - name: envoy.http_connection_manager
      #            config:
      #              stat_prefix: http443
      #              codec_type: AUTO
      #              rds:
      #                route_config_name: "443"
      #                config_source:
      #                  api_config_source:
      #                      api_type: REST_LEGACY
      #                      refresh_delay: 10s
      #                      cluster_names: [rds]

      # Example for testing explicit routes (route_config vs rds)
      - name: http8081
        address:
          socket_address: { address: 0.0.0.0, port_value: 8081 }
        filter_chains:
        - filters:
          - name: envoy.http_connection_manager
            # TODO: add mixer
            config:
              stat_prefix: ingress_http8080
              codec_type: AUTO
              route_config:
                name: local_route
                virtual_hosts:
                - name: local_service
                  domains: ["*"]
                  routes:
                  - match: { prefix: "/" }
                    route: { cluster: out.pilot }


      - name: tcp-zvpn-pilot
        address:
          socket_address: { address: 0.0.0.0, port_value: 15003 }
        filter_chains:
        - filters:
          - name: envoy.tcp_proxy
            config:
              # listener_manager_impl.cc - if false, will attempt to convert to proto - not implemented for tcp_proxy
              deprecated_v1: true
              value:
                stat_prefix: tcp_pilot
                route_config:
                    routes:
                    - cluster: zvpn.pilot

      - name: tcp-zvpn-ca
        address:
          socket_address: { address: 0.0.0.0, port_value: 8060 }
        filter_chains:
        - filters:
          - name: envoy.tcp_proxy
            config:
              # listener_manager_impl.cc - if false, will attempt to convert to proto - not implemented for tcp_proxy
              deprecated_v1: true
              value:
                stat_prefix: tcp_ca
                route_config:
                    routes:
                    - cluster: zvpn.ca


      clusters:
      - name: rds
        connect_timeout: 0.25s
        type: STRICT_DNS
        lb_policy: ROUND_ROBIN
        hosts:
          # TODO(costin): add TLS
          - { socket_address: { address: "istio-pilot.istio-system", port_value: 8080 }}
          # Local debugging/testing
          #- { socket_address: { address: "localhost", port_value: 15008 }}

      # Direct zvpn connection to pilot TLS port. This is used with a TCP proxy !
      - name: zvpn.pilot
        connect_timeout: 0.25s
        type: STRICT_DNS
        lb_policy: ROUND_ROBIN
        hosts:
          - { socket_address: { address: "istio-pilot", port_value: 15003 }}

      # Connection to Istio CA. Service name must match the one for CA exposing gRPC.
      - name: zvpn.ca
        connect_timeout: 0.25s
        lb_policy: ROUND_ROBIN
        type: EDS
        eds_cluster_config:
          service_name: istio-ca-ilb.istio-system.svc.cluster.local|grpc
          eds_config:
            api_config_source:
              api_type: REST_LEGACY
              cluster_names: [rds]
              refresh_delay: 10s

      # Example/temp zvpn pointing to pilot, using its normal name, to verify we can create the tunnel.
      # The service name should match what CDS generates - this section attempts to test merging of manual and CDS.
      - name: out.pilot
        connect_timeout: 0.25s
        lb_policy: ROUND_ROBIN
        type: EDS
        eds_cluster_config:
          service_name: istio-pilot.istio-system.svc.cluster.local|http-discovery
          eds_config:
            api_config_source:
              api_type: REST_LEGACY
              cluster_names: [rds]
              refresh_delay: 10s


---
apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: istio-ingress
  namespace: istio-system
  annotations:
    sidecar.istio.io/inject: "false"
    keel.sh/pollSchedule: "@every 10m"
  labels:
    # Will auto-update on gcr.io pushes
    keel.sh/policy: force
    keel.sh/trigger: poll

spec:
  replicas: 1
  template:
    metadata:
      annotations:
        sidecar.istio.io/inject: "false"
        keel.sh/pollSchedule: "@every 30m"
      labels:
        istio: ingress
        # Will auto-update on gcr.io pushes
        keel.sh/policy: force
        keel.sh/trigger: poll
    spec:
      serviceAccountName: istio-ingress-service-account
      containers:
      - name: istio-ingress
        # Manually start envoy, without using pilot-agent, so we can override the config.
        command: ["/usr/local/bin/envoy"]
        image: gcr.io/istio-testing/proxy_debug:costin
        # Configuration matching pilot-agent.
        args: ["-c", "/etc/envoy/envoy.yaml", "-l", "debug", "--service-cluster", "istio-ingress", "--service-node" , "ingress~~istio-ingress.istio-system~istio-system.svc.cluster.local"]
        imagePullPolicy: Always
        ports:
        - containerPort: 80
        - containerPort: 443
        # Static config
        - containerPort: 8080
        - containerPort: 8443
        # Ports for control plane, zero vpn
        - containerPort: 15003
        - containerPort: 15006
        - containerPort: 8060
        # Additional ports for 'zero vpn' using separate ports. Must have a corresponding port in
        # the service.
        - containerPort: 8081
        - containerPort: 5201
        - containerPort: 5202
        env:
        - name: POD_NAME
          valueFrom:
            fieldRef:
              apiVersion: v1
              fieldPath: metadata.name
        - name: POD_NAMESPACE
          valueFrom:
            fieldRef:
              apiVersion: v1
              fieldPath: metadata.namespace
        - name: VER
          value: "1"
        - name: RELOAD
          value: "14"

        volumeMounts:
        - name: istio-certs
          mountPath: /etc/certs
          readOnly: true
        - name: envoyconfig
          mountPath: /etc/envoy
        # Original multi-SAN default cert.
        - name: httpbin-tls
          mountPath: /etc/istio/ingress-certs
          readOnly: true
        # SNI certs
        - name: httpbin-tls
          mountPath: /etc/istio/httpbin-certs
          readOnly: true
        - name: httpbin-raw-tls
          mountPath: /etc/istio/httpbin-raw-certs
          readOnly: true
        resources:
          requests:
            cpu: 1500m
            memory: "1G"
          limits:
            cpu: 2000m
            memory: "2G"
      volumes:
      - name: istio-certs
        secret:
          secretName: istio.default
          optional: true
      # Manually mount until node-agent can automate it
      - name: httpbin-raw-tls
        secret:
            secretName: httpbin-raw-tls
            optional: true
      - name: httpbin-tls
        secret:
            secretName: httpbin-tls
            optional: true
      - name: ingress-certs
        secret:
          secretName: istio-ingress-certs
          optional: true
      - name: envoyconfig
        configMap:
            name: envoy-config

---
apiVersion: v1
kind: Service
metadata:
  name: istio-ingress
  namespace: istio-system
  labels:
    istio: ingress
spec:
  type: LoadBalancer
  ports:
  - port: 80
    name: http
  - port: 443
    name: https
  # Additional ports for control plane, mesh using zero vpn
  - port: 15003
    name: http-pilot
  - port: 15006
    name: grpc-mixer
  - port: 8060
    name: grpc-ca
  # Additional ports for services exposed using zero vpn. For each service add a port here.
  - port: 5201
    name: iperf3
  - port: 5202
    name: iperf3-raw
  - port: 8081
    name: http-test
  - port: 8080
    name: http-manual
  - port: 8443
    name: https-manual
  selector:
    istio: ingress
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: istio-ingress-service-account
  namespace: istio-system
---
